1:artisan命令行命令：
    1：清除权限缓存
        php artisan permission:cache-reset
        app()->make(\Zhulei\Permission\PermissionRegistrar::class)->forgetCachedPermissions();
    2：创建权限
        php artisan permission:create-permission name guard?
    3：创建角色
        php artisan permission:create-role name guard? permissions|permissions?
    4:命令行显示守卫下面管理员有哪些权限
        ['', '管理员', '报表管理员'];
        ['add', '✔', '.'];
        显示样式(default|borderless|compact|box)
        php artisan permission:show guard? style?


2:Contracts契约接口
    1:Permission权限接口
        1：roles 权限所属角色 BelongsToMany
        2：findByName  通过权限名,guard_name查找权限(name, guardName)
        3：findById  通过权限Id,guard_name查找权限 (id, guardName)
        4：findOrCreate 通过权限名查找或新建权限  (name, guardName)

    2:Role角色接口
        1:permissions 角色所拥有的权限 BelongsToMany
        2：findByName  通过角色名,guard_name查找权限(name, guardName)
        3：findById  通过角色Id,guard_name查找权限 (id, guardName)
        4：findOrCreate 通过角色名查找或新建角色  (name, guardName)
        5：hasPermissionTo 判断给定的角色是否有权限执行 (string/\Zhulei\Permission\Contracts\Permission permission)

3:异常类 src/Exceptions/
    1：守卫不匹配 GuardDoesNotMath
        create方法  用守卫名添加角色或者权限在系统守卫集合中不存在
    2：权限已经存在 PermissionAlreadyExists
        create方法  添加的权限名在某个守卫下已经存在了
    3：权限不存在 PermissionDoesNotExist
        create方法 添加的权限名在守卫下不存在
        withId  这个ID在权限中不存在
    4：角色已经存在  RoleAlreadyExists
        create  角色名在守卫下已经存在
    5：角色不存在  RoleDoesNotExist
        named 没有这个角色名
        withId 角色ID不存在
    6:未认证 UnauthorizedException
        forRoles  提示用户角色不对 参数为正确的角色数组
        forPermissions  提示用户权限不对  参数是正确的权限数组
        forRolesOrPermissions 提示用户没有角色或者权限的权限  参数为正确的角色或权限数组
        notLoggedIn  提示用户未登陆
        getRequiredRoles 返回正确的角色数组
        getRequiredPermissions 返回正确的权限数组
    如果你想覆盖默认403异常可以：
    public function render($request, Exception $exception)
    {
        if ($exception instanceof \Zhulei\Permission\Exceptions\UnauthorizedException) {
            // Code here ...
        }
        return parent::render($request, $exception);
    }

4：中间件 如果想使用中间件需要到app/Http/Kernel.php  $routeMiddleware中添加中间件名指向下面的类
    可以在控制器中使用，路由中使用中间件 ->middleware('permission') ->middleware(CheckAge::class); ->middleware('permission:add|edit');
     kernel中的$middlewareGroups是中间件组。
     中间件参数需要在request, $next,后传递参数。
     在中间件响应发送给浏览器之后调用可以在中间件中定义 terminate($request, $response)方法


    1：权限中间件   PermissionMiddleware
    2:角色中间件   RoleMiddleware
    3:角色或权限中间件 RoleOrPermissionMiddleware

    想使用中间件必须在app/http/kernel.php中添加如下：
    protected $routeMiddleware = [
        // ...
        'role' => \Zhulei\Permission\Middlewares\RoleMiddleware::class,
        'permission' => \Zhulei\Permission\Middlewares\PermissionMiddleware::class,
        'role_or_permission' => \Zhulei\Permission\Middlewares\RoleOrPermissionMiddleware::class,
    ];
    控制器中使用路由：
    public function __construct()
    {
        $this->middleware(['role_or_permission:super-admin|edit']);
    }
    public function __construct()
    {
        $this->middleware(['role:super-admin','permission:publish|edit']);
    }

    路由中使用：
    Route::group(['middleware' => ['role:super-admin']], function () {
        //
    });

    Route::group(['middleware' => ['permission:publish']], function () {
        //
    });

    Route::group(['middleware' => ['role:super-admin','permission:publish']], function () {
        //
    });

    Route::group(['middleware' => ['role_or_permission:super-admin']], function () {
        //
    });

    Route::group(['middleware' => ['role_or_permission:publish']], function () {
        //
    });


5：模型类
    1：权限模型 Permission
        1：roles 权限属于哪些角色 BelongsToMany
            有一个roles和permission，和role_has_permissions表，是多对多的关系，在permission模型中有roles方法，哪些角色拥有此权限。
            return $this->belongsToMany(
                'Zhulei\Permission\Models\Role::class/Zhulei\Permission\Models\Role',//当前模型想获取的模型字符串或字符串类名
                'role_has_permissions'//关联连接表名，如果不设置默认是用按两个表字符顺序连接的两个表permission_users
                'permission_id',//当前模型在连接表中的外键
                'role_id'//另一个模型（第一个参数）在连接表里的外键
            );
            多对多关系：
                一个角色拥有多个权限，一个权限属于多个角色，是多对多关系，两个模型中都使用belongsToMany()方法来定义。
                有三个表。roles,permissions,role_has_permissions(此表中有permission_id,role_id)
                关联和被关联表都使用
                return $this->belongsToMany('想获取的模型'，'关联表', '当前模型在关联表中的外键','另一个表在关联表中的外键');
                定义好之后就可以使用$user->roles动态属性获取到所有的角色数组。
                定义好之后也可以使用链式的进行过滤查询$user->roles()->orderBy('id')->get();
                获取关联连接表字段：
                    pivot代表中间表模型，可以像Eloquent模型一样使用
                    foreach($user->roles as $role){
                        $role->pivot->create_at;
                    }
                    模型情况下中间表只有两个字段，如果有其他字段，需要在定义关联声明时明确指出，
                    return $this->belongsToMany('App\Role')->withPivot('column1', 'column2');
                    如果想让中间表自动维护created_at,updated_at:
                    return $this->belongsToMany('App\Role')->withTimestamps();
        2:__construct
            权限模型初始化，可以传入属性数组，
            如果传入就用传入的守卫名，如果没传入用配置文件里的守卫名，给当前模型设置守卫名，然后设置当前模型表名。

            protected $guarded 不允许自动填充的字段
            protected $fillable 允许自动填充（白名单）

            Post::create($request->all())//自动批量赋值并过滤
            我们也可以使用如下形式：
                $post = new Post($data);
                $post->user_id = Auth::id();
                $post->save();
                或者使用fill()方法，它也会使用过滤。














